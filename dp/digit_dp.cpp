    ///Пример задачи на ДП по цифрам:
    ///Есть Q запросов l, r, m
    ///Найти к-во цифр от l до r, где сумма цифр % m == 0

    ///dp[просчитанная длина чисел][сумма цифр][флаг]
    //dp[len][0..m][f] = x
    //len = 1..n, where n = искомая длина

    ///f - флаг
    ///Если f = 0, то любые числа будут x < y
    ///Если f = 1, то любые числа будут x = y
    ///Если f = 2, то любые числа будут x > y
    ///Пример: если y = 5, то 1..4 (f=0), 5 (f=1), 6..+inf (f=2)

    ///Пребираем все len в пределах нужных границ
    ///y передаётся в функцию. Это r, по факту.

    ///Если f = 0, то x < y
    ///Значит, что бы мы не приписали в конец x, он всё ещё будет меньше y
    ///Мы никак не можем сделать x >= y

    ///Если f = 2, то x > y
    ///Закономерность такая же. Мы не можем сделать x <= y НИКАК.
    ///Флаг всегда сохраняется

    ///Если f = 1, то x = y
    ///Флаг остаётся 1, если припишем одинаковые числа
    ///Флаг станет 0, если припишем x число, строго меньшее, чем число на той же позиции у y
    ///Флаг станет 2, если припишем x число, строго большее, чем число на той же позиции у y

    ///ПРОБЛЕМА: ДП умеет находить только для ..r, а надо l..r
    ///РЕШЕНИЕ: Префиксные суммы. Считаем для ..r и ..l, потом вычитаем

    ///В DP мы храним НЕ сами числа, А их количество, т.к. существует много числел с одинаковыми конфигурациями.

    ///------------------------------------------------------------------------------------------------------
    ///ПРИБЛИЗИТЕЛЬНЫЙ КОД ДЛЯ ПОИСКА ОТВЕТА НА ПРЕФИКСЕ ..R:

    int dp[n][m][3]; ///n - длина числа R, m - дано, нужный нам остаток
    vector<int> v; ///Разложенное на цифры число R (в объяснении выше v[i] это y)

    ///Инициализация DP для первой цифры
    ///ПРИМЕЧАНИЕ: не забываем, у нас 0-индексация. Длина 0 это длина 1 и так далее.
    for(int l = 1; i <= 9; i++) {
        if(i < v[0]) {
            dp[0][i % m][0]++;
        } else
        if(i == v[0]) {
            dp[0][i % m][1]++;
        } else
        if(i > v[0]) {
            dp[0][i % m][2]++;
        }
    }

    ///Головной цикл DP
    for(int len = 1; len < n; len++) {
        ///Предыдущая сумма; Сумма до прибавления цифры cc
        for(int sum = 0; sum <= m; sum++) {
            ///Добавляемое число
            for(int c = 0; c <= 9; c++) {

                ///Обрабатываем изменение для предыдущего f=0
                dp[len][(sum + c) % m][0] += dp[len - 1][sum][0];

                ///Обрабатываем изменение для предыдущего f=2
                dp[len][(sum + c) % m][2] += dp[len - 1][sum][2];

                ///Обрабатываем изменения для предыдущего f=1. Их три, как и написано выше.
                if(c < v[len]) {
                    dp[len][(sum + c) % m][0] += dp[len - 1][sum][1];
                } else
                if(c == v[len]) {
                    dp[len][(sum + c) % m][1] += dp[len - 1][sum][1];
                } else
                if(c > v[len]){
                    dp[len][(sum + c) % m][2] += dp[len - 1][sum][1];
                }
            }
        }
    }

    ///Извлечение ответа
    ll ans = 0;
    for(int len = 0; len < n; len++) {
        ans += dp[len][0][0];
        ans += dp[len][0][1];
        ///Если x меньше y на префиксе, префикс x всё равно меньше y
        ///Кроме случая, когда взята полная длина
        if(len != n - 1) {
            ans += dp[len][0][2];
        }
    }

    ///ОТВЕТ В ans.
